---
title: '[백준] [리스트] [1546] 평균 구하기'
date: 2026-01-2 16:51:30
category: 'Algorithm'
draft: false
---

알고리즘을 다시 공부하기 시작했다.

그간 BE 소양을 기르기 위해 다양한 공부를 해왔었는데, k8s부터 퍼블릭 클라우드, Kafka, Grafana, gRPC 등등

업무와 관련된 스킬들을 업그레이드해왔었다.

실제로 업무에 도움도 많이 되었었고, 요즘 BE에서 요구되는 지식들을 많이 익히기도 했지만 내 업무에 대한 싫증이 생겼던 것 같다.

이제는... 이직을 시도해봐도 좋을 때라고 생각이 들기도 했고, 새로운 도메인을 접해보고 싶기도 했다.

손 놓은지 몇 년만에 다시 공부하려니 너무 막막해서 `Do It! 알고리즘 코딩테스트 Python`을 구매하여 처음부터 다시 시작해보기로 했다.

그간 평일에는 거의 손대지 못하고 있었지만 26년이 되었으니 올해의 목표는 이 책을 마스터하고 이직도 달성하는 것으로 하기로 했다.

처음 접하게 된 알고리즘(자료구조)는 리스트 자료구조이다. 이 챕터의 목표는 Python에서 사용되는 리스트를 더 잘 활용하기 위함이 목표이다.

컴퓨터 공학에는 배열과 리스트의 개념이 있다.

> 배열(Array): 데이터가 메모리 상에 연속적으로 배치된다. 선언할 때 크기가 고정되며, 각 요소들에 index를 통해 바로 접근이 가능하다. 하지만 데이터를 추가 / 삭제할 때 앞 뒤 데이터를 밀거나 당겨야 해서 비효율적일 수 있다.  
> 리스트(List): 데이터가 메모리 곳곳에 흩어져 있으며, 노드에 값이 저장되고 각 노드에서 다음 노드를 가르키는 주소 값을 저장한다. 필요할 때 마다 요소를 추가/삭제 가능하지만, 배열과 다르게 직접적으로 인덱스를 통해 접근이 불가능하고 순회를 통해 접근 가능하다.

| 비교군 | 배열(Array) | 리스트(List) |
| --- | --- | --- |
| 조회 (Access) | O(1) - 매우 빠름 | O(n) - 순차 탐색 |
| 삽입/삭제 | O(n) - 데이터 이동 필요 | O(1) - 주소값만 변경 |
| 메모리 할당 | 정적 (컴파일 단계) | 동적 (런타임 단계) |

Python에서는 사용되는 리스트 자료형은 흔히 이론적으로 알려진 연결 리스트(Linked List)가 아니다. 파이썬의 리스트는 `동적 배열(Dynamic Array)`로 구현되어 있어, 배열처럼 index를 통해 연속된 공간을 할당 받으며 `append()`를 통해 기존 배열 크기보다 더 데이터가 들어오게 되면 더 큰 메모리 공간을 할당 받아 기존 데이터를 복사한다.

![array_vs_list](https://www.kodeclik.com/assets/Array-vs-List.png)

평균 구하기 문제는 N개의 점수가 주어졌을 때 점수 \* 100 / 최대값으로 새로운 점수를 구해서 이에 대한 평균 값을 제출하는 문제이다.

나는 다음과 같은 해결 방안을 생각했다.

> N과 각 점수 입력 받음  
> 최대 값 구함  
> 새로운 점수들을 구해서 평균을 구함

이 때 각각 새로운 점수를 구한 뒤 평균을 구하는 방식으로 구현하였는데, 이렇게 풀어도 정답이 되기는 한다. 하지만, 좀 더 시간을 단축 가능한데, 수학의 분배법칙을 이용하는 방식이다. 전체 최대값은 미리 구한 뒤, 전체 점수를 더하고 \* 100 / 최대 값 / N 을 계산하면 한 번의 계산으로 정답을 확인할 수 있게 된다.

```
"""
    [1546] 평균 구하기
    링크: https://www.acmicpc.net/problem/1546
    카테고리: 자료구조 > 리스트
    날짜: 2025.12.06 17:04PM
    걸린 시간: 10분
"""
def new_score(score):
    return (score / max_score) * 100

def average(arr):
    return sum(arr) / len(arr)

N = int(input())
scores = list(map(int, input().split()))
max_score = max(scores)
print(average(list(map(new_score, scores))))
"""
함수를 따로 선언하는 대신에 아래와 같이 분배법칙을 이용한다면 총 계산 횟수를 1회로 줄일 수 있다.

sum_score = sum(scores)
print(sum_score * 100 / max_score / N)
"""
```
