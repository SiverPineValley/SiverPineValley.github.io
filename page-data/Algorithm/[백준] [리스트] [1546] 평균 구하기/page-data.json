{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm/[백준] [리스트] [1546] 평균 구하기/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","author":"JonginPark","siteUrl":"https://SiverPineValley.github.io","comment":{"disqusShortName":"","utterances":"SiverPineValley/devlog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"26a50768-5d54-5c63-a9b7-cdd90a4627a5","excerpt":"알고리즘을 다시 공부하기 시작했다. 그간 BE 소양을 기르기 위해 다양한 공부를 해왔었는데, k8s부터 퍼블릭 클라우드, Kafka, Grafana, gRPC 등등 업무와 관련된 스킬들을 업그레이드해왔었다. 실제로 업무에 도움도 많이 되었었고, 요즘 BE…","html":"<p>알고리즘을 다시 공부하기 시작했다.</p>\n<p>그간 BE 소양을 기르기 위해 다양한 공부를 해왔었는데, k8s부터 퍼블릭 클라우드, Kafka, Grafana, gRPC 등등</p>\n<p>업무와 관련된 스킬들을 업그레이드해왔었다.</p>\n<p>실제로 업무에 도움도 많이 되었었고, 요즘 BE에서 요구되는 지식들을 많이 익히기도 했지만 내 업무에 대한 싫증이 생겼던 것 같다.</p>\n<p>이제는… 이직을 시도해봐도 좋을 때라고 생각이 들기도 했고, 새로운 도메인을 접해보고 싶기도 했다.</p>\n<p>손 놓은지 몇 년만에 다시 공부하려니 너무 막막해서 <code class=\"language-text\">Do It! 알고리즘 코딩테스트 Python</code>을 구매하여 처음부터 다시 시작해보기로 했다.</p>\n<p>그간 평일에는 거의 손대지 못하고 있었지만 26년이 되었으니 올해의 목표는 이 책을 마스터하고 이직도 달성하는 것으로 하기로 했다.</p>\n<p>처음 접하게 된 알고리즘(자료구조)는 리스트 자료구조이다. 이 챕터의 목표는 Python에서 사용되는 리스트를 더 잘 활용하기 위함이 목표이다.</p>\n<p>컴퓨터 공학에는 배열과 리스트의 개념이 있다.</p>\n<blockquote>\n<p>배열(Array): 데이터가 메모리 상에 연속적으로 배치된다. 선언할 때 크기가 고정되며, 각 요소들에 index를 통해 바로 접근이 가능하다. 하지만 데이터를 추가 / 삭제할 때 앞 뒤 데이터를 밀거나 당겨야 해서 비효율적일 수 있다.<br>\n리스트(List): 데이터가 메모리 곳곳에 흩어져 있으며, 노드에 값이 저장되고 각 노드에서 다음 노드를 가르키는 주소 값을 저장한다. 필요할 때 마다 요소를 추가/삭제 가능하지만, 배열과 다르게 직접적으로 인덱스를 통해 접근이 불가능하고 순회를 통해 접근 가능하다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>비교군</th>\n<th>배열(Array)</th>\n<th>리스트(List)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>조회 (Access)</td>\n<td>O(1) - 매우 빠름</td>\n<td>O(n) - 순차 탐색</td>\n</tr>\n<tr>\n<td>삽입/삭제</td>\n<td>O(n) - 데이터 이동 필요</td>\n<td>O(1) - 주소값만 변경</td>\n</tr>\n<tr>\n<td>메모리 할당</td>\n<td>정적 (컴파일 단계)</td>\n<td>동적 (런타임 단계)</td>\n</tr>\n</tbody>\n</table>\n<p>Python에서는 사용되는 리스트 자료형은 흔히 이론적으로 알려진 연결 리스트(Linked List)가 아니다. 파이썬의 리스트는 <code class=\"language-text\">동적 배열(Dynamic Array)</code>로 구현되어 있어, 배열처럼 index를 통해 연속된 공간을 할당 받으며 <code class=\"language-text\">append()</code>를 통해 기존 배열 크기보다 더 데이터가 들어오게 되면 더 큰 메모리 공간을 할당 받아 기존 데이터를 복사한다.</p>\n<p><img src=\"https://www.kodeclik.com/assets/Array-vs-List.png\" alt=\"array_vs_list\"></p>\n<p>평균 구하기 문제는 N개의 점수가 주어졌을 때 점수 * 100 / 최대값으로 새로운 점수를 구해서 이에 대한 평균 값을 제출하는 문제이다.</p>\n<p>나는 다음과 같은 해결 방안을 생각했다.</p>\n<blockquote>\n<p>N과 각 점수 입력 받음<br>\n최대 값 구함<br>\n새로운 점수들을 구해서 평균을 구함</p>\n</blockquote>\n<p>이 때 각각 새로운 점수를 구한 뒤 평균을 구하는 방식으로 구현하였는데, 이렇게 풀어도 정답이 되기는 한다. 하지만, 좀 더 시간을 단축 가능한데, 수학의 분배법칙을 이용하는 방식이다. 전체 최대값은 미리 구한 뒤, 전체 점수를 더하고 * 100 / 최대 값 / N 을 계산하면 한 번의 계산으로 정답을 확인할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"\"\"\n    [1546] 평균 구하기\n    링크: https://www.acmicpc.net/problem/1546\n    카테고리: 자료구조 > 리스트\n    날짜: 2025.12.06 17:04PM\n    걸린 시간: 10분\n\"\"\"\ndef new_score(score):\n    return (score / max_score) * 100\n\ndef average(arr):\n    return sum(arr) / len(arr)\n\nN = int(input())\nscores = list(map(int, input().split()))\nmax_score = max(scores)\nprint(average(list(map(new_score, scores))))\n\"\"\"\n함수를 따로 선언하는 대신에 아래와 같이 분배법칙을 이용한다면 총 계산 횟수를 1회로 줄일 수 있다.\n\nsum_score = sum(scores)\nprint(sum_score * 100 / max_score / N)\n\"\"\"</code></pre></div>","frontmatter":{"title":"[백준] [리스트] [1546] 평균 구하기","date":"January 02, 2026"}}},"pageContext":{"slug":"/Algorithm/[백준] [리스트] [1546] 평균 구하기/","previous":{"fields":{"slug":"/aws/aws_1_2/"},"frontmatter":{"title":"1-2) IAM Policy"}},"next":{"fields":{"slug":"/Algorithm/[백준] [리스트] [11659] 구간 합 구하기 4/"},"frontmatter":{"title":"[백준] [리스트] [11659] 구간 합 구하기 4"}}}},"staticQueryHashes":["3128451518","643154061"],"slicesMap":{}}