{"componentChunkName":"component---src-templates-blog-post-js","path":"/코테/programmers_hash/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","author":"JonginPark","siteUrl":"https://SiverPineValley.github.io","comment":{"disqusShortName":"","utterances":"SiverPineValley/devlog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"b614e8f6-33c1-57ed-b227-5f9151dad95a","excerpt":"코테 연습할겸해서 풀었던 해시 문제들에 대한 풀이를 올려보았다. [Level 1] 완주하지 못한 선수 매우 간단한 문제로, 참가자와 완료한 선수들 명단이 있는데, 이중 완료하지 못한 선수 이름을 리턴하기만 하면 된다. 해시 맵에 묶여있어서 map을 글대로 사용해서 아래와 같이 작성했다. 가장 효율적인 풀이를 보니 그냥 두 vector…","html":"<p>코테 연습할겸해서 풀었던 해시 문제들에 대한 풀이를 올려보았다.</p>\n<h2 id=\"level-1-완주하지-못한-선수\" style=\"position:relative;\"><a href=\"#level-1-%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%84%A0%EC%88%98\" aria-label=\"level 1 완주하지 못한 선수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Level 1] 완주하지 못한 선수</h2>\n<p>매우 간단한 문제로, 참가자와 완료한 선수들 명단이 있는데, 이중 완료하지 못한 선수 이름을 리턴하기만 하면 된다.<br>\n해시 맵에 묶여있어서 map을 글대로 사용해서 아래와 같이 작성했다.<br>\n가장 효율적인 풀이를 보니 그냥 두 vector를 정렬해서 차례로 비교하다가 다른 값이 나오면 그대로 리턴, 혹은 가장 마지막 참가자를 리턴하면 정답이다.<br>\n굳이 해시를 사용하지 않아도 최적의 풀이를 찾아낼 수 있는 문제였다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// 프로그래머스\n// hash - 완주하지 못한 선수\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nstring solution(vector&lt;string&gt; participant, vector&lt;string&gt; completion) {\n    string answer = &quot;&quot;;\n    int size = completion.size();\n    map&lt;string,int&gt; m;\n    \n    for(string c : completion) {\n        if (!m.count(c)) {\n            m[c] = 1;\n        } else {\n            m[c] = m[c] + 1;\n        }\n    }\n    \n        for(string p : participant) {\n        if (!m.count(p)) {\n            answer = p;\n            break;\n        } else if (m[p] == 0) {\n            answer = p;\n            break;\n        } else {\n            m[p] = m[p] - 1;\n        }\n    }\n    \n    return answer;\n}</code></pre></div>\n<h2 id=\"level-2-전화번호-목록\" style=\"position:relative;\"><a href=\"#level-2-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D\" aria-label=\"level 2 전화번호 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Level 2] 전화번호 목록</h2>\n<p>전화번호 목록은 전화번호 리스트 중에 Prefix가 되는 전화번호가 있으면 false를 리턴하는 문제이다.<br>\n이번에도 간단한 문제이지만, 효율성 테스트를 통과하기가 조금 더 어려워졌다.<br>\nHash Map을 사용하여 아래와 같이 풀었지만, 마지막 효율성 테스트가 도저히 통과가 되질 않았다..<br>\n아무래도 처음에 Map을 생성하는 행위와, map을 순회하면서 비교하는 행위의 까지 하여 O(n^2) 의 시간복잡도라 풀리지 않은 것 같다.\nMap을 담은 조건은 각 string의 길이를 key로 잡았고, 비교할 때 이보다 큰 길이의 string들만 비교하도록 하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nbool solution(vector&lt;string&gt; phone_book) {\n    set&lt;int&gt; phone_size;\n    unordered_map&lt;int,vector&lt;string&gt;&gt; map_book;\n    \n    // Map 생성\n    for(string each_book : phone_book) {\n        int length = each_book.length();\n        map_book[length].push_back(each_book);\n        phone_size.insert(length);\n    }\n    \n    // Map 비교\n    for(auto length = phone_size.begin(); length != phone_size.end(); length++) {\n        for (string source : map_book[*length]) {\n                for(auto cmp = next(length,1); cmp != phone_size.end(); cmp++) {\n                    for (string target : map_book[*cmp]) {\n                        if(source == target.substr(0, *length)) return false;\n                    }\n            }\n        }\n    }\n    \n    return true;\n}</code></pre></div>\n<p>이 문제의 핵심은 string의 길이 순으로 정렬하는게 아니라, 사전순으로 정렬하는 것이 정답이다.<br>\n아래와 같이 사전순으로 정렬하게 되면 O(n*m)의 효율성으로 통과가 가능하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nbool solution(vector&lt;string&gt; phone_book) {\n    unordered_map&lt;string,int&gt; map_book;\n    \n    // Map 생성\n    for(string each_book : phone_book)\n        map_book[each_book] = 1;\n    \n    // Map 비교\n    for(string each_book : phone_book) {\n        string book = &quot;&quot;;\n        for (int i = 0; i &lt; each_book.size(); i++) {\n            book += each_book[i];\n            if (map_book[book] &amp;&amp; book != each_book) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}</code></pre></div>\n<h2 id=\"level-2-위장\" style=\"position:relative;\"><a href=\"#level-2-%EC%9C%84%EC%9E%A5\" aria-label=\"level 2 위장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Level 2] 위장</h2>\n<p>각 의상의 종류별로 카운팅하여 마지막에 곱셈만 해주면 되는 문제라 쉽게 풀린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nint solution(vector&lt;vector&lt;string&gt;&gt; clothes) {\n    int answer = 1;\n    \n    unordered_map&lt;string,int&gt; cloth_map;\n    int cloth_type = 0;\n\n    for(vector&lt;string&gt; cloth : clothes) {\n        if(cloth_map.count(cloth[1]) &gt; 0) {\n            cloth_map[cloth[1]]++;\n        } else {\n            cloth_map[cloth[1]] = 1;\n            cloth_type++;\n        }\n    }\n    \n    unordered_map&lt;string,int&gt;::iterator iter;\n    for(iter = cloth_map.begin(); iter!= cloth_map.end(); iter++){\n        answer = answer + (iter-&gt;second * answer);   \n    }\n    return answer-1;\n}</code></pre></div>\n<h2 id=\"level-3-베스트-앨범\" style=\"position:relative;\"><a href=\"#level-3-%EB%B2%A0%EC%8A%A4%ED%8A%B8-%EC%95%A8%EB%B2%94\" aria-label=\"level 3 베스트 앨범 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Level 3] 베스트 앨범</h2>\n<p>베스트 앨범은 각 장르별, 재생수별로 정렬된 노래들을 각 장르별로 2곡씩 선별하여 정렬된 노래의 고유 번호를 출력하는 문제이다.<br>\nmap으로 장르별 총 재생 수, 장르별 각 노래별 재생 수를 담아놓고, 장르별로 최대 2곡씩 뽑아서 answr에 push하면 된다.\n각 정렬 시 내림차순, 오름차순 정렬을 해야 해서 별도의 정렬 함수를 생성하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 내림차순 정렬\nbool cmp_total(const pair&lt;string,int&gt;&amp; left, const pair&lt;string,int&gt;&amp; right) {\n\treturn right.second &lt; left.second;\n}\n\n// 재생수 같으면, 고유번호의 오름차순\n// 재생수는 내림차순\nbool cmp_each(const pair&lt;int,int&gt;&amp; left, const pair&lt;int,int&gt;&amp; right) {\n    if (left.first == right.first) {\n        return left.second &lt; right.second;\n    }\n    return right.first &lt; left.first;\n}\n\nvector&lt;int&gt; solution(vector&lt;string&gt; genres, vector&lt;int&gt; plays) {\n    int size = genres.size();\n    vector&lt;int&gt; answer;\n    map&lt;string,int&gt; genre_total;\n    map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt; genre_play;\n    \n    // map 생성\n    for(int i = 0; i &lt; size; i++) {\n        if (genre_total.count(genres[i]) == 0) {\n            genre_total[genres[i]] = plays[i];\n            vector&lt;pair&lt;int,int&gt;&gt; temp;\n            temp.push_back(make_pair(plays[i],i));\n            genre_play[genres[i]] = temp;\n            continue;\n        }\n        genre_total[genres[i]] = genre_total[genres[i]] + plays[i];\n        auto temp = genre_play[genres[i]];\n        temp.push_back(make_pair(plays[i],i));\n        genre_play[genres[i]] = temp;\n    }\n    \n    // 장르별 정렬\n    vector&lt;pair&lt;string, int&gt; &gt; arr;\n    for (const auto &amp;item : genre_total) {\n        arr.emplace_back(item);\n    }\n    sort(arr.begin(), arr.end(), cmp_total);\n    \n    // answer에 담기\n    for(auto it = arr.begin(); it != arr.end(); it++) {\n        auto each = genre_play[it-&gt;first];\n        sort(each.begin(), each.end(), cmp_each);\n        int idx = 0;\n        int each_size = each.size();\n        while(idx &lt; 2 &amp;&amp; idx &lt; each_size) {\n            auto each_value = each[idx].second;\n            answer.push_back(each_value);\n            idx++;\n        }\n    }\n    \n    return answer;\n}</code></pre></div>","frontmatter":{"title":"[프로그래머스 연습문제] 해시","date":"October 04, 2021"}}},"pageContext":{"slug":"/코테/programmers_hash/","previous":{"fields":{"slug":"/gatsby/gatsby_deploy/"},"frontmatter":{"title":"[Gatsby Blog 만들기 - 2] Gastby Blog 배포 (gatsby-starter-bee)"}},"next":{"fields":{"slug":"/http/samesite/"},"frontmatter":{"title":"[HTTP] 크롬 브라우저의 쿠키 정책과 SameSite"}}}},"staticQueryHashes":["3128451518","643154061"],"slicesMap":{}}