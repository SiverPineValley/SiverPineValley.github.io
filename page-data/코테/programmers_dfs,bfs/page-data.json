{"componentChunkName":"component---src-templates-blog-post-js","path":"/코테/programmers_dfs,bfs/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog"}},"markdownRemark":{"id":"dc900779-3962-5664-8c80-1a9e5ed43bf8","excerpt":"오랜만에 DFS, BFS 문제들을 풀어보았다.\n주로 DFS 기법을 자주 사용하여 풀었다. [Level 2] 타겟 넘버 DFS, BFS 문제 중 간단한 편에 속하는 문제이다. Queue를 사용하였고, 노드별 가지가 2개밖에 되지 않아 간단하게 구현 가능하다.\n다만, 기존에 C…","html":"<p>오랜만에 DFS, BFS 문제들을 풀어보았다.\n주로 DFS 기법을 자주 사용하여 풀었다.</p>\n<h2>[Level 2] 타겟 넘버</h2>\n<p>DFS, BFS 문제 중 간단한 편에 속하는 문제이다. Queue를 사용하였고, 노드별 가지가 2개밖에 되지 않아 간단하게 구현 가능하다.\n다만, 기존에 C++로 문제를 제출한 이력이 있어서 Go언어로 다시 풀어보았다. Go언어에는 Queue와 같은 자료구조 라이브러리가 부실해서 직접 Queue 자료구조를 구현하였다.\nQueue 구현 시 <code class=\"language-text\">https://yoongrammer.tistory.com/54</code> 올려진 자료를 참고하였다.</p>\n</br>\n<p>먼저, Queue 자료구조를 구현한 부분은 아래와 같다.\nQueue 타입을 선언하고 Queue 타입의 포인터 리터럴을 받는 함수 세개를 구현하였다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Queue <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">Pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n    <span class=\"token punctuation\">}</span>\n    \n    v <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span>   \n<span class=\"token punctuation\">}</span></code></pre></div>\n</br>\n<p>실제 코드는 아래와 같다.\n위의 Queue 자료구조 사용 시 주의할 점은 Pop()에서 interface{}를 리턴하므로 Queue에 넣었던 타입으로 형변환해서 사용해야 한다는 점이다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Queue <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">*</span>Queue<span class=\"token punctuation\">)</span> <span class=\"token function\">Pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span>\n    <span class=\"token punctuation\">}</span>\n    \n    v <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    <span class=\"token operator\">*</span>q <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span>   \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Node <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Now <span class=\"token builtin\">int</span>\n    Value <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>numbers <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> target <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>result <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    op <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n    length <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n    q <span class=\"token operator\">:=</span> Queue<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    \n    q<span class=\"token punctuation\">.</span><span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>numbers<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    q<span class=\"token punctuation\">.</span><span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>numbers<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">for</span> <span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">IsEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        v <span class=\"token operator\">:=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">Pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span>\n        \n        <span class=\"token keyword\">if</span> v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">==</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n            r1 <span class=\"token operator\">:=</span> v<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">+</span> op<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> numbers<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            r2 <span class=\"token operator\">:=</span> v<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">+</span> op<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> numbers<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            \n            <span class=\"token keyword\">if</span> r1 <span class=\"token operator\">==</span> target <span class=\"token punctuation\">{</span>\n                result<span class=\"token operator\">++</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> r2 <span class=\"token operator\">==</span> target <span class=\"token punctuation\">{</span>\n                result<span class=\"token operator\">++</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token punctuation\">}</span>\n        \n        q<span class=\"token punctuation\">.</span><span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">+</span> op<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> numbers<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        q<span class=\"token punctuation\">.</span><span class=\"token function\">Push</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">{</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">+</span> op<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> numbers<span class=\"token punctuation\">[</span>v<span class=\"token punctuation\">.</span>Now <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>[Level 3] 네트워크</h2>\n<p>네트워크는 노드별 연결되어 있는 개수를 찾는 문제이다.\nBFS를 사용하였으며, 방문 가능한 모든 노드를 한번에 방문한다.\n각 방문한 노드는 visit에 기록하여, 이미 방문한 노드는 다시 방문하지 않도록 한다.\n하나의 네트워크를 찾았으면, 다음 방문하지 않은 노드부터 네트워크를 찾기 시작한다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint solution(int n, vector&lt;vector&lt;int&gt;&gt; computers) {\n    int answer = 0;\n    vector&lt;bool&gt; visit(n, false);\n    queue&lt;int&gt; q;\n    \n    for(int i = 0; i &lt; n; i++) {\n        if (visit[i]) {\n            continue;\n        }\n        \n        q.push(i);\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            if (visit[v]) continue;\n            visit[v] = true;\n            \n            for(int j = 0; j &lt; n; j++) {\n                if(computers[v][j] &amp;&amp; !visit[j]) {\n                    q.push(j);\n                }\n            }\n        }\n        answer++;\n    }\n    \n    return answer;\n}</code></pre></div>\n<h2>[Level 3] 단어 변환</h2>\n<p>단어 변환은 begin 단어에서부터 words 내에 있는 단어 중 하나의 문자만 변경해서 target까지 최소 몇 번의 변환을 거쳐야 가능한지 구하는 문제이다.\n역시 BFS 알고리즘을 사용하였으며, 각 노드에는 현재 단어와 방문한 단어를 기록해놓는다.\n네트워크보다 복잡한 점은 이미 방문했던 노드를 한번씩만 기록하는게 아니라, 각 노드를 방문한 시점에 방문했던 노드가 각각 다르다는 것이다.\n따라서 queue에 위와 같이 현재 단어와 방문했던 단어를 모두 기록했다.\n네트워크보단 복잡하지만 엄청 어렵거나 하진 않았다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nstruct alpa {\n    string now;\n    map&lt;string,bool&gt; visit;\n};\n\nbool compare(string now, string target) {\n    int length = now.size();\n    int diff = 0;\n    for(int i = 0; i &lt; length; i++) {\n        if (now[i] != target[i]) {\n            if (diff) {\n                return false;\n            }\n            diff++;\n        }\n    }\n    \n    return diff == 1;\n}\n\nint solution(string begin, string target, vector&lt;string&gt; words) {\n    int answer = 51;\n    int length = words.size();\n    queue&lt;alpa&gt; q;    \n    q.push({begin,map&lt;string,bool&gt;()});\n    \n    while(!q.empty()) {\n        alpa f = q.front();\n        q.pop();\n        \n        if (f.now == target) {\n            int tempAnswer = f.visit.size();\n            if (tempAnswer &lt; answer &amp;&amp; tempAnswer != 0) {\n                answer = tempAnswer;\n            }\n            continue;\n        }\n        \n        f.visit[f.now] = true;\n        for(int i = 0; i &lt; length; i++) {\n            if (f.now == words[i] || f.visit.count(words[i]) &gt; 0) {\n                continue;\n            }\n            \n            if (compare(f.now, words[i])) {\n                q.push({words[i], f.visit});\n            }\n        }\n    }\n    \n    if (answer == 51) {\n        answer = 0;\n    }\n    \n    return answer;\n}</code></pre></div>\n<h2>[Level 3] 여행경로</h2>\n<p>여행경로는 모든 티켓을 사용해서 모든 노드를 방문할 수 있는 경우의 수 중에서 알파벳순으로 가장 앞에 오는 경로를 리턴하면 된다.\n탐색은 동일하게 했고, 추가로 각 경로 탐색 시 시간을 줄이기 위해 map으로 경로를 찾을 수 있도록 하였다.\n처음에는 좀 더 쉬운 방법으로 풀이해보려 했는데, 모든 케이스를 고려 안하면 정답이 안되서... 결국 완전탐색하게 하였다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nstruct Route {\n    string target;\n    int index;\n};\n\nstruct Status {\n    string now;\n    int cnt;\n    vector&lt;bool&gt; visited;\n    vector&lt;string&gt; route;\n};\n\nvector&lt;string&gt; compare(vector&lt;string&gt; a, vector&lt;string&gt; b) {\n    int size = a.size();\n    if (size == 0) return b;\n    \n    for(int i = 0; i &lt; size; i ++) {\n        if (a[i] &lt; b[i]) {\n            return a;\n        } else if (a[i] == b[i]) {\n            continue;\n        }\n        return b;\n    }\n    \n    return a;\n}\n\nvector&lt;string&gt; solution(vector&lt;vector&lt;string&gt;&gt; tickets) {\n    vector&lt;string&gt; answer;\n    int length = tickets.size();\n    map&lt;string,vector&lt;Route&gt;&gt; route;\n    \n    // Route 생성\n    for (int i = 0; i &lt; length; i++) {\n        vector&lt;string&gt; ticket = tickets[i];\n        if (route.count(ticket[0]) == 0) {\n            vector&lt;Route&gt; vc;\n            vc.push_back({ticket[1], i});\n            route.insert({ticket[0], vc});\n        } else {\n            route[ticket[0]].push_back({ticket[1], i});\n        }\n    }\n    \n    // 탐색\n    queue&lt;Status&gt; q;\n    q.push({&quot;ICN&quot;, 1, vector&lt;bool&gt;(length,false), vector&lt;string&gt;(1, &quot;ICN&quot;)});\n    \n    while (!q.empty()) {\n        Status f = q.front();\n        q.pop();\n        \n        if (f.cnt == length + 1) {\n            answer = compare(answer, f.route);\n            continue;\n        }\n        \n        int targetSize = route[f.now].size();\n        for (int i = 0; i &lt; targetSize; i++) {\n            Route tgt = route[f.now][i];\n            Status temp = f;\n            \n            if (temp.visited[tgt.index]) {\n                continue;\n            }\n            \n            temp.visited[tgt.index] = true;\n            temp.route.push_back(tgt.target);\n            q.push({tgt.target, temp.cnt + 1, temp.visited, temp.route});\n        }\n    }\n    \n    return answer;\n}</code></pre></div>","frontmatter":{"title":"[프로그래머스 연습문제] BFS, DFS","date":"March 01, 2022","description":null}},"previous":{"fields":{"slug":"/http/jwt&paesto/"},"frontmatter":{"title":"[HTTP] JWT Token과 PASETO"}},"next":{"fields":{"slug":"/Golang/basic_grammer/"},"frontmatter":{"title":"[Go 언어 문법 정리] 01. 기초 문법"}}},"pageContext":{"id":"dc900779-3962-5664-8c80-1a9e5ed43bf8","previousPostId":"98d66527-65f6-5582-9c60-e24bcec5e240","nextPostId":"01ed610c-5ff3-5416-a39f-f2ecc33dadc5"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}