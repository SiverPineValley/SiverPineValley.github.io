{"componentChunkName":"component---src-templates-blog-post-js","path":"/kafka/kafka_2_3/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","author":"JonginPark","siteUrl":"https://SiverPineValley.github.io","comment":{"disqusShortName":"","utterances":"SiverPineValley/devlog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"1c4c82cc-4fed-55be-a6c1-4a8047478138","excerpt":"데이터의 저장은 브로커의 역할 중 하나이다. 카프카를 실행할 때 config/server.properties의  옵션에 지정한 경로에 데이터를 저장한다. (토픽 이름 + Partition…","html":"<ul>\n<li>데이터의 저장은 브로커의 역할 중 하나이다.</li>\n<li>카프카를 실행할 때 config/server.properties의 <code class=\"language-text\">log.dir</code> 옵션에 지정한 경로에 데이터를 저장한다. (토픽 이름 + Partition 번호를 조합)\n- 해당 경로 안에는 여러 파일이 생성되는데, <code class=\"language-text\">log</code>에는 메시지와 메타데이터, <code class=\"language-text\">index</code>에는 메시지의 오프셋을 인덱싱한 파일, <code class=\"language-text\">timeindex</code> 파일에는 타임스탬프 값을 기준으로 인덱싱한 데이터가 저장된다.</li>\n</ul>\n</br>\n<div align=\"left\">\n  <img src=\"./images/스크린샷 2024-12-07 오후 2.35.55.png\" width=\"500px\" />\n</div>\n</br>\n<ul>\n<li>로그 파일은 파일 시스템을 나눠서 저장하는데, 다음과 같은 설정에 의해 로그 세그먼트 파일의 크기가 정해진다. 로그 파일의 이름은 해당 파일의 offset 시작 번호이다. 현재 작성되고 있는 세그먼트 파일을 <code class=\"language-text\">active segment</code>라고 한다. 일반 세그먼트 파일은 retention 옵션에 따라 삭제 대상으로 지정된다.\n<ul>\n<li><code class=\"language-text\">log.segment.bytes</code>: 바이트 단위의 최대 세그먼트 크기 기정 (기본값: 1GB)</li>\n<li><code class=\"language-text\">log.rolls.ms(hours)</code>: 세그먼트가 신규 생성된 이후 다음 파일로 넘어가는 주기. (기본값: 7일)</li>\n</ul>\n</li>\n</ul>\n</br>\n<div align=\"left\">\n  <img src=\"./images/스크린샷 2024-12-07 오후 2.37.21.png\" width=\"500px\" />\n</div>\n</br>\n<ul>\n<li>세그먼트의 삭제 주기는 다음과 같은 옵션에 의해 정해진다. 세그먼트의 삭제는 파일 단위로 진행되므로, 특정 레코드(키, 값, 오프셋, 타임스탬프) 단위로는 삭제/수정이 불가능하다.\n<ul>\n<li><code class=\"language-text\">cleanup.policy=delete</code>: 세그먼트의 삭제를 결정하는 옵션</li>\n<li><code class=\"language-text\">retention.ms(minitues, hours)</code>: 세그먼트를 보유할 최대 기간. (기본값: 7일)</li>\n<li><code class=\"language-text\">retention.bytes</code>: 파티션 당 로그 적재 바이트 값. (기본값: -1, 지정하지 않음)</li>\n<li><code class=\"language-text\">log.retention.check.interval.ms</code>: 세그먼트가 삭제 영역에 들어왔는지 확인하는 간격. (기본값: 5분)</li>\n</ul>\n</li>\n</ul>\n</br>\n<div align=\"left\">\n  <img src=\"./images/스크린샷 2024-12-07 오후 2.38.06.png\" width=\"500px\" />\n</div>\n</br>\n<ul>\n<li>세그먼트의 압축이란 zip 파일과 같은 파일의 압축(compression)과는 다른 개념이다. 여기서 압축이란 <strong>메시지의 키 별로 해당 메시지의 레코드 중 오래된 데이터를 삭제하는 정책</strong>을 말한다. 그렇기 때문에 delete 와 다르게, 일부 레코드만 삭제될 수 있다. 압축은 세그먼트를 제외한 데이터가 대상이다. 이러한 compact 옵션은 key-value 스토어의 느낌으로 사용할 때 사용될 수 있다.\n<ul>\n<li><code class=\"language-text\">cleanup.policy=compact</code>: 세그먼트를 압축하는 옵션.</li>\n</ul>\n</li>\n<li>compact 옵션에는 테일/헤드 영역이 존재한다.\n<ul>\n<li>테일 영역 (클린 로그): 압축 정책에 의해 압축이 완료된 세그먼트. 중복 메시지 키가 없다.</li>\n<li>헤드 영역 (더티 로그): 압축 정책이 되기 전 레코드들. 중복된 메시지 키가 있다.</li>\n<li><code class=\"language-text\">min.cleanable.dirty.ratio</code>: compact 옵션의 압축 시점은 테일 영역과 헤드 영역의 비율을 지정한 설정 값으로 정할 수 있다. 예를 들어 0.5로 설정 하면, 테일 영역과 헤드 영역의 수가 동일할 대 압축이 진행된다. 0.9인 경우 헤드 영역을 최대한 모았다가 한번에 압축하므로, 압축의 효율이 좋다. 0.1인 경우 자주 압축을 시도하므로 용량에서는 이점이 있다.</li>\n</ul>\n</li>\n</ul>\n</br>\n<div align=\"left\">\n  <img src=\"./images/스크린샷 2024-12-07 오후 2.38.51.png\" width=\"500px\" />\n</div>\n</br>","frontmatter":{"title":"2-3) 로그와 세그먼트","date":"December 07, 2024"}}},"pageContext":{"slug":"/kafka/kafka_2_3/","previous":{"fields":{"slug":"/kafka/kafka_2_2/"},"frontmatter":{"title":"2-2) Kafka 클러스터와 브로커, 주키퍼"}},"next":{"fields":{"slug":"/kafka/kafka_2_4/"},"frontmatter":{"title":"2-4) 복제 (replication)"}}}},"staticQueryHashes":["3128451518","643154061"],"slicesMap":{}}