{"componentChunkName":"component---src-templates-blog-post-js","path":"/kafka/kafka_2_7/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","author":"JonginPark","siteUrl":"https://SiverPineValley.github.io","comment":{"disqusShortName":"","utterances":"SiverPineValley/devlog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"db81cae5-8376-5f19-89f8-e6cc6ac91571","excerpt":"레코드는 타임스탬프, 헤더, 오프셋, 메시지 키, 메시지 값으로 구성되어 있다. Producer가 생성한 레코드가 브로커로 전송되면, 타임스탬프와 오프셋이 지정된다. 브로커에 한 번 적재된 데이터는 수정 불가하고, retention 정책(용량/기간)에 의해서만 삭제될 수 있다. 레코드의 는 스트림 프로레싱에서 활용하기 위해 시간을 저장하는 용도로 사용된다. 카프카 0.10.0.0 이후 버전부터 추가된 타임스탬프는 Unix timestamp…","html":"</br>\n<div align=\"left\">\n  <img src=\"./images/스크린샷 2024-12-07 오후 2.47.10.png\" width=\"500px\" />\n</div>\n</br>\n<ul>\n<li>레코드는 타임스탬프, 헤더, 오프셋, 메시지 키, 메시지 값으로 구성되어 있다. Producer가 생성한 레코드가 브로커로 전송되면, 타임스탬프와 오프셋이 지정된다. 브로커에 한 번 적재된 데이터는 수정 불가하고, retention 정책(용량/기간)에 의해서만 삭제될 수 있다.</li>\n<li>레코드의 <code class=\"language-text\">타임스탬프(timestamp)</code>는 스트림 프로레싱에서 활용하기 위해 시간을 저장하는 용도로 사용된다. 카프카 0.10.0.0 이후 버전부터 추가된 타임스탬프는 Unix timestamp가 포함되며, 프로듀서가 따로 설정하지 않으면 기본적으로는 프로듀스 레코드의 생성 시간이 기록된다. <code class=\"language-text\">message.timestamp.type</code>을 지정하면 브로커 적재 시간 (Log Append Time)으로 설정할 수도 있다.</li>\n<li>레코드의 <code class=\"language-text\">오프셋(offset)</code>은 프로듀서가 전송한 레코드가 브로커에 저장될 때 지정된다. 오프셋은 0부터 시작하여 1씩 증가된다. 컨슈머는 오프셋을 기반으로 처리한 데이터와 앞으로 처리해야 할 데이터를 구분한다. 각 메시지는 파티션별로 고유한 오프셋을 가지므로 컨슈머에서 중복 처리하지 않기 위한 용도로도 사용된다.</li>\n<li>레코드의 <code class=\"language-text\">헤더(header)</code>는 0.11부터 제공된 기능이다. key/value 데이터를 추가할 수 있으며 레코드의 스키마 버전이나 포맷과 같이 데이터 프로세싱에 참고될만한 정보를 담아 사용할 수 있다.</li>\n<li><code class=\"language-text\">메시지 키(key)</code>는 처리하고자 하는 메시지를 구분하는 용도로 사용되며, 이를 <code class=\"language-text\">파티셔닝(Partitioning)</code>이라고 한다. 파티셔닝에 사용되는 메시지 키는 <code class=\"language-text\">파티셔너(Partitioner)</code>에 따라 토픽의 파티션 번호가 지정된다. 파티셔너는 레코드가 토픽 내 어느 파티션으로 전해지는 지를 정해주는 역할을 한다. 키는 필수 값이 아니라 값이 없으면 null로 되며 메시지 키가 null인 레코드는 특정 토픽 파티션에 라운드 로빈으로 전해진다. 키 값이 null이 아니면  키의 해쉬값에 따라 특정 파티션에 전달된다. 즉, 같은 키 값의 데이터들은 같은 파티션에 순서대로 전달되므로 순서가 보장된다고 볼 수 있다.</li>\n<li><code class=\"language-text\">메시지 값(value)</code>은 실절적으로 처리할 데이터가 담기는 공간이다. 메시지 포맷은 제너릭으로 사용자에 의해 정해진다. Float, []Byte, String 등 다양한 형태로 지정 가능하며, 필요에 따라 사용자 지정 포맷으로 직렬화/역직렬화 클래스를 만들어서 사용할 수 있다. 메시지에 어떤 값으로 직렬화/역직렬화되어 저장되었는지 알 수 없으므로 컨슈머는 미리 역직렬화 포맷을 알고 있어야 한다.</li>\n</ul>","frontmatter":{"title":"2-7) 레코드","date":"December 07, 2024"}}},"pageContext":{"slug":"/kafka/kafka_2_7/","previous":{"fields":{"slug":"/kafka/kafka_2_5/"},"frontmatter":{"title":"2-5) ISR (In-Sync-Replicas)"}},"next":{"fields":{"slug":"/kafka/kafka_2_6/"},"frontmatter":{"title":"2-6) 토픽과 파티션"}}}},"staticQueryHashes":["3128451518","643154061"],"slicesMap":{}}