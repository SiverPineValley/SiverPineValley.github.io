{"componentChunkName":"component---src-templates-blog-post-js","path":"/server/loadbalancer/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","author":"JonginPark","siteUrl":"https://SiverPineValley.github.io","comment":{"disqusShortName":"","utterances":"SiverPineValley/devlog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"1bc87a81-542c-500c-8f2c-640da0206c0a","excerpt":"1. 부하 분산 방법 대부분의 인터넷을 기반으로 오픈되어 있는 서비스들의 실운영 서버는 클라우드 환경이던 컨테이너 환경이던 트래픽을 견디게 하기 위해 여러 가지 방법들을 사용한다. 서비스의 부하를 견디게 하기 위한 방법에는 크게 두 가지가 있다. : Server 하드웨어의 스펙을 높이는 방법. : Server…","html":"<h1 id=\"1-부하-분산-방법\" style=\"position:relative;\"><a href=\"#1-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"1 부하 분산 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 부하 분산 방법</h1>\n<p>대부분의 인터넷을 기반으로 오픈되어 있는 서비스들의 실운영 서버는 클라우드 환경이던 컨테이너 환경이던 트래픽을 견디게 하기 위해 여러 가지 방법들을 사용한다. 서비스의 부하를 견디게 하기 위한 방법에는 크게 두 가지가 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">Scale Up</code>: Server 하드웨어의 스펙을 높이는 방법.</p>\n</li>\n<li>\n<p><code class=\"language-text\">Scale Out</code>: Server를 병렬적으로 여러 대로 늘려서 부하를 분산시키는 방법.</p>\n</li>\n</ul>\n<p>두 가지 방법 모두 그럴듯한데, 경우에 따라 다르긴 하지만 <code class=\"language-text\">Scale Up</code> 보다는 <code class=\"language-text\">Scale Out</code>의 장점 때문에 이를 선택하는 경우가 많다. 첫 번째로 하드웨어 스펙을 높이는 것 보단, 비슷한 스펙으로 서버를 하나 더 구축하는 것이 비용면에서 더 효율적이다. 두 번째로 서버 하나에서 장애가 발생하더라도 나머지 서버가 살아 있다면 무중단 서비스를 보장할 수 있다. <code class=\"language-text\">로드밸런싱</code> 이라는 개념은 바로 이 부분에서 나오는데, 트래픽을 여러 서버로 분산시키는 기술을 로드밸런싱이라고 한다.</p>\n<h1 id=\"2-로드밸런싱\" style=\"position:relative;\"><a href=\"#2-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1\" aria-label=\"2 로드밸런싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 로드밸런싱</h1>\n<h2 id=\"21-로드밸런싱이란\" style=\"position:relative;\"><a href=\"#21-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1%EC%9D%B4%EB%9E%80\" aria-label=\"21 로드밸런싱이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.1 로드밸런싱이란?</h2>\n<p>앞서 설명한 바와 같이, 로드밸런싱이란 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도 저하를 고려하여 적절히 분산처리하여 해결해주는 서비스를 의미한다. 주요 기능으로는 아래와 같다고 볼 수 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">NAT(Network Address Translation)</code>: 사설 IP 주소를 공인 IP 주소로 바꾸는 데 사용하는 통신망의 주소변환기</p>\n</li>\n<li>\n<p><code class=\"language-text\">Tunneling</code>: 인터넷 상에서 보이지 않는 통로를 생성. 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 해제 가능.</p>\n</li>\n<li>\n<p><code class=\"language-text\">DSR(Dynamic Source Routing Protocol)</code>: 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념이다.</p>\n</li>\n</ul>\n<div align=\"center\">\n  <img src=\"./images/dsr.png\" width=\"600px\" />\n</div>\n<h2 id=\"22-로드밸런서의-종류\" style=\"position:relative;\"><a href=\"#22-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"22 로드밸런서의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.2 로드밸런서의 종류</h2>\n<p>로드 밸런서는 OSI Layer의 어떤 단계의 프로토콜을 기준으로 분산처리를 하느냐에 따라 종류가 여러 가지로 나뉜다. 주로 L4와 L7 로드밸런서가 많이 사용되는데, L4부터 IP와 Port 정보를 바탕으로 로드밸런싱이 가능하기 때문이다.</p>\n<h3 id=\"l2\" style=\"position:relative;\"><a href=\"#l2\" aria-label=\"l2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L2</h3>\n<ul>\n<li>Mac 주소를 바탕으로 로드밸런싱한다.</li>\n</ul>\n<h3 id=\"l3\" style=\"position:relative;\"><a href=\"#l3\" aria-label=\"l3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L3</h3>\n<ul>\n<li>IP 주소를 바탕으로 로드밸런싱한다.</li>\n</ul>\n<h3 id=\"l4\" style=\"position:relative;\"><a href=\"#l4\" aria-label=\"l4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L4</h3>\n<ul>\n<li>Network Layer(IP, IPX)나 Transport Layer(TCP, UDP)를 바탕으로 로드밸런싱한다.</li>\n<li>IP 주소와 Port, MAC주소, 전송 프로토콜에 따라 트래픽을 나누는 것이 가능하다.</li>\n<li>TCP, UDP</li>\n</ul>\n<div align=\"center\">\n  <img src=\"./images/l4.png\" width=\"600px\" />\n</div>\n<h3 id=\"l7\" style=\"position:relative;\"><a href=\"#l7\" aria-label=\"l7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>L7</h3>\n<ul>\n<li>Application Layer(사용자의 Request) Level에서 로드밸런싱한다.</li>\n<li>HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산할 수 있다.</li>\n<li>HTTP, HTTPS, FTP</li>\n</ul>\n<div align=\"center\">\n  <img src=\"./images/l7.png\" width=\"600px\" />\n</div>\n<ul>\n<li><code class=\"language-text\">X-Forwarded-For</code>: HTTP 또는 HTTPS 로드 밸런서를 사용할 때 클라이언트의 IP 주소를 식별하는 데 도움을 줍니다.</li>\n<li><code class=\"language-text\">X-Forwarded-Proto</code>: 클라이언트가 로드 밸런서 연결에 사용한 프로토콜(HTTP 또는 HTTPS)을 식별하는 데 도움을 줍니다.</li>\n<li><code class=\"language-text\">X-Forwarded-Port</code>: 클라이언트가 로드 밸런서 연결에 사용한 포트를 식별하는 데 도움을 줍니다.</li>\n</ul>\n<h2 id=\"23-로드밸런서의-알고리즘\" style=\"position:relative;\"><a href=\"#23-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"23 로드밸런서의 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.3 로드밸런서의 알고리즘</h2>\n<p>각 서버별로 적절한 부하 분산을 위해 로드밸런서는 여러 가지 알고리즘들을 사용한다. 알고리즘의 목표는 가장 균형적으로 모든 서버들에게 트래픽을 분산하는 것 이다.</p>\n<ul>\n<li><code class=\"language-text\">라운드로빈 방식(Round Robin)</code>: 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식. 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고 있고, 서버와의 연결이 오래 지속되지 않는 경우 활용하기 적합.</li>\n<li><code class=\"language-text\">가중 라운드로빈 방식(Weighted Round Robin</code>: 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 상이한 경우 사용되는 부하 분산 방식이다.</li>\n<li><code class=\"language-text\">최소 연결 방식(Least Connections)</code>: 요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트패릭 분배. 트래픽으로 인해 세션이 길어지는 경우 선호된다.</li>\n<li><code class=\"language-text\">IP 해시 방식(IP Hash Method)</code>: 사용자의 IP를 Hashing하여 분배하는 방식. 사용자는 항상 같은 서버로 연결되는 것이 보장된다.</li>\n<li><code class=\"language-text\">최소 리스폰스 타임(Least Response Time)</code>: 서버의 연결 상태와 응답시간을 모두 고려하여 트래픽을 분배. 가장 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분한다.</li>\n</ul>\n<p>짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분하는 방식입니다.</p>\n<h2 id=\"24-로드밸런서의-장애-대응\" style=\"position:relative;\"><a href=\"#24-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EC%9D%98-%EC%9E%A5%EC%95%A0-%EB%8C%80%EC%9D%91\" aria-label=\"24 로드밸런서의 장애 대응 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2.4 로드밸런서의 장애 대응</h2>\n<p>서비스와 마찬가지로, 로드 밸런서 역시 장애가 발생하면 서비스 전체에 지장을 주게 될 수 있다. 이를 방지하기 위해 로드밸런서에도 이중화 처리가 가능하다. 다만, 서비스와 같이 모든 서버가 Active인 것이 아니라, Active-Stanby 구조로 서로 Health-Check를 하다가 Active 서버가 죽으면 Stanby가 Active가 되는 방식이다.</p>\n<div align=\"center\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAPoAAAD6AG1e1JrAAABSklEQVR42nVS2W7DMAzL//9hnzZgB7Z2KZrEt2RxkpIU69oaIHyKoigPuBsCdL6B8J+9dAe3pqjo1LY7UnQMcsenJ0rQde764DhlHD4vvhYlypUQcwUTgRRsySxG7414+KfNg+yisiA1xrgUvI0BmVSVMN7PAa+nBaRERlhr9VlkrWwY5whWdlNUNSiqAlNhax9UgDSBuqBxczFyLUZcoanvvFozHD5GzKlhzoQlN/yoonOsSsgbYQVa0iBGaYRnwyxwQlMmu3Wbb5atcfeSLcHLcVaFTcE4h4LTlPydqSNtjq2xl4xHTbHObp5eUsT3NKot7CdHTfB1yU5maNbta2OUMFR2v4pj9cO6vENUmdaCMC/ocQZKhJRgNd688719m3EKCKUiFVKPtIwuj02y7qPvf+Gpl0OKETkn5LQiJdtn/w430NLuzh7gF5XtE3BPRKhwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"active stanby\" title=\"\" src=\"/static/5960b112b49ecf5e4b13c7f6939e099e/c1b63/active-stanby.png\" srcset=\"/static/5960b112b49ecf5e4b13c7f6939e099e/5a46d/active-stanby.png 300w,\n/static/5960b112b49ecf5e4b13c7f6939e099e/0a47e/active-stanby.png 600w,\n/static/5960b112b49ecf5e4b13c7f6939e099e/c1b63/active-stanby.png 1200w\" sizes=\"(max-width: 1200px) 100vw, 1200px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n</div>\n<h1 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h1>\n<p><a href=\"https://nesoy.github.io/articles/2018-06/Load-Balancer\">https://nesoy.github.io/articles/2018-06/Load-Balancer</a> [Nesoy Blog]</br>\n<a href=\"https://m.post.naver.com/viewer/postView.naver?volumeNo=27046347&#x26;memberNo=2521903\">https://m.post.naver.com/viewer/postView.naver?volumeNo=27046347&#x26;memberNo=2521903</a> [네이버 포스트 IT용어사전]</p>","frontmatter":{"title":"로드밸런서의 개념과 종류","date":"September 09, 2022"}}},"pageContext":{"slug":"/server/loadbalancer/","previous":{"fields":{"slug":"/kubernetes/kubernetes_5_5/"},"frontmatter":{"title":"[쿠버네티스 완벽 가이드] 11. 워크로드 API 카테고리 (5) - 잡, 크론잡"}},"next":{"fields":{"slug":"/kubernetes/kubernetes_6_1/"},"frontmatter":{"title":"[쿠버네티스 완벽 가이드] 12. 서비스 API 카테고리 (1) - 서비스 API 카테고리 개요 및 쿠버네티스 클러스터 네트워크와 서비스"}}}},"staticQueryHashes":["3128451518","643154061"],"slicesMap":{}}