{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/programmers_hash/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog"}},"markdownRemark":{"id":"20e71168-158c-55e8-aafb-79eb32e36853","excerpt":"코테 연습할겸해서 풀었던 해시 문제들에 대한 풀이를 올려보았다. [Level 1] 완주하지 못한 선수 매우 간단한 문제로, 참가자와 완료한 선수들 명단이 있는데, 이중 완료하지 못한 선수 이름을 리턴하기만 하면 된다. 해시 맵에 묶여있어서 map…","html":"<p>코테 연습할겸해서 풀었던 해시 문제들에 대한 풀이를 올려보았다.</p>\n<h2>[Level 1] 완주하지 못한 선수</h2>\n<p>매우 간단한 문제로, 참가자와 완료한 선수들 명단이 있는데, 이중 완료하지 못한 선수 이름을 리턴하기만 하면 된다.<br>\n해시 맵에 묶여있어서 map을 글대로 사용해서 아래와 같이 작성했다.<br>\n가장 효율적인 풀이를 보니 그냥 두 vector를 정렬해서 차례로 비교하다가 다른 값이 나오면 그대로 리턴, 혹은 가장 마지막 참가자를 리턴하면 정답이다.<br>\n굳이 해시를 사용하지 않아도 최적의 풀이를 찾아낼 수 있는 문제였다.</p>\n</br>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// 프로그래머스\n// hash - 완주하지 못한 선수\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nstring solution(vector&lt;string&gt; participant, vector&lt;string&gt; completion) {\n    string answer = &quot;&quot;;\n    int size = completion.size();\n    map&lt;string,int&gt; m;\n    \n    for(string c : completion) {\n        if (!m.count(c)) {\n            m[c] = 1;\n        } else {\n            m[c] = m[c] + 1;\n        }\n    }\n    \n        for(string p : participant) {\n        if (!m.count(p)) {\n            answer = p;\n            break;\n        } else if (m[p] == 0) {\n            answer = p;\n            break;\n        } else {\n            m[p] = m[p] - 1;\n        }\n    }\n    \n    return answer;\n}</code></pre></div>\n<h2>[Level 2] 전화번호 목록</h2>\n<p>전화번호 목록은 전화번호 리스트 중에 Prefix가 되는 전화번호가 있으면 false를 리턴하는 문제이다.<br>\n이번에도 간단한 문제이지만, 효율성 테스트를 통과하기가 조금 더 어려워졌다.<br>\nHash Map을 사용하여 아래와 같이 풀었지만, 마지막 효율성 테스트가 도저히 통과가 되질 않았다..<br>\n아무래도 처음에 Map을 생성하는 행위와, map을 순회하면서 비교하는 행위의 까지 하여 O(n^2) 의 시간복잡도라 풀리지 않은 것 같다.\nMap을 담은 조건은 각 string의 길이를 key로 잡았고, 비교할 때 이보다 큰 길이의 string들만 비교하도록 하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nbool solution(vector&lt;string&gt; phone_book) {\n    set&lt;int&gt; phone_size;\n    unordered_map&lt;int,vector&lt;string&gt;&gt; map_book;\n    \n    // Map 생성\n    for(string each_book : phone_book) {\n        int length = each_book.length();\n        map_book[length].push_back(each_book);\n        phone_size.insert(length);\n    }\n    \n    // Map 비교\n    for(auto length = phone_size.begin(); length != phone_size.end(); length++) {\n        for (string source : map_book[*length]) {\n                for(auto cmp = next(length,1); cmp != phone_size.end(); cmp++) {\n                    for (string target : map_book[*cmp]) {\n                        if(source == target.substr(0, *length)) return false;\n                    }\n            }\n        }\n    }\n    \n    return true;\n}</code></pre></div>\n<p>이 문제의 핵심은 string의 길이 순으로 정렬하는게 아니라, 사전순으로 정렬하는 것이 정답이다.<br>\n아래와 같이 사전순으로 정렬하게 되면 O(n*m)의 효율성으로 통과가 가능하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nbool solution(vector&lt;string&gt; phone_book) {\n    unordered_map&lt;string,int&gt; map_book;\n    \n    // Map 생성\n    for(string each_book : phone_book)\n        map_book[each_book] = 1;\n    \n    // Map 비교\n    for(string each_book : phone_book) {\n        string book = &quot;&quot;;\n        for (int i = 0; i &lt; each_book.size(); i++) {\n            book += each_book[i];\n            if (map_book[book] &amp;&amp; book != each_book) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}</code></pre></div>\n<h2>[Level 2] 위장</h2>\n<p>각 의상의 종류별로 카운팅하여 마지막에 곱셈만 해주면 되는 문제라 쉽게 풀린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nint solution(vector&lt;vector&lt;string&gt;&gt; clothes) {\n    int answer = 1;\n    \n    unordered_map&lt;string,int&gt; cloth_map;\n    int cloth_type = 0;\n\n    for(vector&lt;string&gt; cloth : clothes) {\n        if(cloth_map.count(cloth[1]) &gt; 0) {\n            cloth_map[cloth[1]]++;\n        } else {\n            cloth_map[cloth[1]] = 1;\n            cloth_type++;\n        }\n    }\n    \n    unordered_map&lt;string,int&gt;::iterator iter;\n    for(iter = cloth_map.begin(); iter!= cloth_map.end(); iter++){\n        answer = answer + (iter-&gt;second * answer);   \n    }\n    return answer-1;\n}</code></pre></div>\n<h2>[Level 3] 베스트 앨범</h2>\n<p>베스트 앨범은 각 장르별, 재생수별로 정렬된 노래들을 각 장르별로 2곡씩 선별하여 정렬된 노래의 고유 번호를 출력하는 문제이다.<br>\nmap으로 장르별 총 재생 수, 장르별 각 노래별 재생 수를 담아놓고, 장르별로 최대 2곡씩 뽑아서 answr에 push하면 된다.\n각 정렬 시 내림차순, 오름차순 정렬을 해야 해서 별도의 정렬 함수를 생성하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 내림차순 정렬\nbool cmp_total(const pair&lt;string,int&gt;&amp; left, const pair&lt;string,int&gt;&amp; right) {\n\treturn right.second &lt; left.second;\n}\n\n// 재생수 같으면, 고유번호의 오름차순\n// 재생수는 내림차순\nbool cmp_each(const pair&lt;int,int&gt;&amp; left, const pair&lt;int,int&gt;&amp; right) {\n    if (left.first == right.first) {\n        return left.second &lt; right.second;\n    }\n    return right.first &lt; left.first;\n}\n\nvector&lt;int&gt; solution(vector&lt;string&gt; genres, vector&lt;int&gt; plays) {\n    int size = genres.size();\n    vector&lt;int&gt; answer;\n    map&lt;string,int&gt; genre_total;\n    map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt; genre_play;\n    \n    // map 생성\n    for(int i = 0; i &lt; size; i++) {\n        if (genre_total.count(genres[i]) == 0) {\n            genre_total[genres[i]] = plays[i];\n            vector&lt;pair&lt;int,int&gt;&gt; temp;\n            temp.push_back(make_pair(plays[i],i));\n            genre_play[genres[i]] = temp;\n            continue;\n        }\n        genre_total[genres[i]] = genre_total[genres[i]] + plays[i];\n        auto temp = genre_play[genres[i]];\n        temp.push_back(make_pair(plays[i],i));\n        genre_play[genres[i]] = temp;\n    }\n    \n    // 장르별 정렬\n    vector&lt;pair&lt;string, int&gt; &gt; arr;\n    for (const auto &amp;item : genre_total) {\n        arr.emplace_back(item);\n    }\n    sort(arr.begin(), arr.end(), cmp_total);\n    \n    // answer에 담기\n    for(auto it = arr.begin(); it != arr.end(); it++) {\n        auto each = genre_play[it-&gt;first];\n        sort(each.begin(), each.end(), cmp_each);\n        int idx = 0;\n        int each_size = each.size();\n        while(idx &lt; 2 &amp;&amp; idx &lt; each_size) {\n            auto each_value = each[idx].second;\n            answer.push_back(each_value);\n            idx++;\n        }\n    }\n    \n    return answer;\n}</code></pre></div>","frontmatter":{"title":"[프로그래머스 연습문제] 해시","date":"October 04, 2021","description":null}},"previous":{"fields":{"slug":"/web/jwt&paesto/"},"frontmatter":{"title":"[Web] JWT Token과 PASETO"}},"next":{"fields":{"slug":"/web/jwt&paesto/"},"frontmatter":{"title":"[Web] JWT Token과 PASETO"}}},"pageContext":{"id":"20e71168-158c-55e8-aafb-79eb32e36853"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}